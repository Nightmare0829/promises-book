"use strict";
var regexpRegexp = /^\/(.*)\/([gimy]*)$/;
var hankakuAlphaNum = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
var zenkakuAlphaNum = "ａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ０１２３４５６７８９";
exports.jpHira = /[ぁ-ゖ]/;
exports.jpKana = /[ァ-ヺ]/;
exports.jpKanji = /(?:[々〇〻\u3400-\u9FFF\uF900-\uFAFF]|[\uD840-\uD87F][\uDC00-\uDFFF])/;
exports.jpChar = combine(exports.jpHira, exports.jpKana, exports.jpKanji);
var regexpSpecialChars = "¥*+.?{}()[]^$-|/".split("");
function concat() {
    "use strict";
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    var result = args.reduce(function (p, c) {
        if (typeof c === "string") {
            return p + c;
        }
        else if (c instanceof RegExp) {
            return p + c.source;
        }
        else {
            throw new Error("unknown type: " + c);
        }
    }, "");
    return new RegExp(result);
}
exports.concat = concat;
function combine() {
    "use strict";
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    var result = args.map(function (arg) {
        if (typeof arg === "string") {
            return arg;
        }
        else if (arg instanceof RegExp) {
            return arg.source;
        }
        else {
            throw new Error("unknown type: " + arg);
        }
    }).join("|");
    return concat("(?:", result, ")");
}
exports.combine = combine;
function addBoundary(arg) {
    "use strict";
    var result;
    if (typeof arg === "string") {
        result = arg;
    }
    else if (arg instanceof RegExp) {
        result = arg.source;
    }
    else {
        throw new Error("unknown type: " + arg);
    }
    return concat('\\b', result, '\\b');
}
exports.addBoundary = addBoundary;
function parseRegExpString(str) {
    "use strict";
    var result = str.match(regexpRegexp);
    if (!result) {
        return null;
    }
    return new RegExp(result[1], result[2]);
}
exports.parseRegExpString = parseRegExpString;
function spreadAlphaNum(str) {
    "use strict";
    var result = str.split("").map(function (v) {
        var tmpIdx1 = hankakuAlphaNum.indexOf(v.toUpperCase());
        var tmpIdx2 = hankakuAlphaNum.indexOf(v.toLowerCase());
        if (tmpIdx1 === -1 && tmpIdx2 === -1) {
            return v;
        }
        else if (tmpIdx1 === tmpIdx2) {
            return "[" + v + zenkakuAlphaNum.charAt(tmpIdx1) + "]";
        }
        else {
            return "[" + v.toUpperCase() + v.toLowerCase() + zenkakuAlphaNum.charAt(tmpIdx1) + zenkakuAlphaNum.charAt(tmpIdx2) + "]";
        }
    }).join("");
    return new RegExp(result);
}
exports.spreadAlphaNum = spreadAlphaNum;
function addDefaultFlags(regexp) {
    "use strict";
    var flags = "gm";
    if (regexp.ignoreCase) {
        flags += "i";
    }
    return new RegExp(regexp.source, flags);
}
exports.addDefaultFlags = addDefaultFlags;
function escapeSpecialChars(str) {
    "use strict";
    regexpSpecialChars.forEach(function (char) {
        str = str.replace(new RegExp("\\" + char, "g"), "\\" + char);
    });
    return str;
}
exports.escapeSpecialChars = escapeSpecialChars;
function collectAll(regexp, src) {
    "use strict";
    if (!regexp.global) {
        throw new Error("g flag is required");
    }
    var resultList = [];
    var result;
    do {
        result = regexp.exec(src);
        if (result) {
            resultList.push(result);
        }
    } while (result);
    return resultList;
}
exports.collectAll = collectAll;
function equals(a, b) {
    "use strict";
    if (a.source !== b.source) {
        return false;
    }
    if (a.global !== b.global) {
        return false;
    }
    if (a.ignoreCase !== b.ignoreCase) {
        return false;
    }
    if (a.multiline !== b.multiline) {
        return false;
    }
    return true;
}
exports.equals = equals;
//# sourceMappingURL=regexp.js.map